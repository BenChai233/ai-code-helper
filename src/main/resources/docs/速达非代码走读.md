# 服务架构
## speedaf-cheetah-basic核心模块：
1. 基础API模块（speedaf-cheetah-basic-api）
2. 公共组件模块（speedaf-cheetah-basic-common）  
包含多个子模块：  
common-core：核心配置、常量、枚举和工具类  
common-log：日志相关功能  
common-security：安全认证相关功能
3. 网关模块（speedaf-cheetah-basic-gateway）  
作为系统的统一入口，包含过滤器、处理器等网关组件
4. 日志模块（speedaf-cheetah-basic-log）  
专门处理系统日志功能
5. 登录模块（speedaf-cheetah-basic-login）  
处理用户认证和登录逻辑
6. 用户模块（speedaf-cheetah-basic-member）  
管理用户相关信息
7. 服务模块（speedaf-cheetah-basic-service）  
是系统的主要业务逻辑承载模块
8. 运单模块（speedaf-cheetah-basic-waybill）  
处理运单相关的业务逻辑

## speedaf-cheetah-pds核心模块：
1. api: 对外接口模块
2. manager: 核心业务模块
3. pda: PDA设备相关功能
4. wms: 仓储管理系统相关
5. download: 下载导出功能
6. comm: 公共组件和核心逻辑



## service模块拆分：
客户端：存放各种dto（入参对象）、vo（返回对象）、param（入参对象）、validate（分组校验）类

服务提供者：核心业务处理逻辑（基础层、服务层、接口层）

## service分层架构
1. controller（传统接口层）
2. service（业务逻辑层）
3. manager（mapper业务处理层）
4. mapper（数据持久层）

# 业务逻辑
## 运营管理-中心订单查询-导出
1. 创建导出任务 -- /downloadTask/add
    1. 根据ExcelType注册导出任务
2. xxl-job定时任务扫描任务 -- @XxlJob("centralWaybillDownloadTask")
3. 执行定时任务
    1. 根据ExcelType选择策略类 -- ExcelTypeEnum 
    2. 执行策略类导出任务 -- ExportStrategy
        1. 通过BigEasyExcelUtil输出到服务器临时目录下-- exportPageCentralWaybill
        2. 上传到oss存储
    3. feign回写任务状态 --writeBackTask
4. 系统设置-下载中心查询任务与下载

## 运营管理-称重扫描-揽件扫描
接口：/manager/pickedScan/add

前提：已有运单（快递、整车、零担录入）

文件上传：/manager/file/upload

扫描后返回结果，前端缓存，没有list接口

业务逻辑：

1. 校验合法性
2. 查询运单详情，进行清关提货业务
    1. （清关提货指货物在到达目的地国家后，经过海关检查、缴纳税费等手续完成后，从海关监管区域提取货物的过程。）
    2. 在用户进行揽收扫描时，检查是否已存在清关提货记录，如果不存在则自动生成一条清关提货轨迹节点
3. 校验运单相关状态
4. 计算到件抛重
    1. 货物到达目的地（目的港/目的仓）后，由目的端物流服务商重新测量并计算出的抛重（体积重量）
    2. 计算公式：抛重（kg）= （长（cm）×宽（cm）×高（cm））/抛重系数
        1. 国际快递系数：5000
        2. 空运专线：6000
        3. 国内快递：8000/6000
5. 揽收上锁,避免并发提交
6. 新增揽件扫描记录
7. 释放锁
8. mq推送揽件扫描到订单中心
9. 揽收短信发送
    1. 揽收后短信发给寄件人

## 数据权限过滤
@DataAuthFilter(filterFields = {"accessSites", "forecastSites"})

filterFields参数指定需要进行权限过滤的字段名

DataAuthAspect：

环绕通知，

addAuthFilter：

通过反射机制，动态修改方法参数对象中指定字段的值，将用户有权访问的网点编码集合设置到参数对象中。（只修改前端入参，没有动态修改sql）

# 代码示例
## 查询示例
### Example查询
```java
@Override
public ReturnExchange geByWaybillCode(String waybillCode) {
return returnExchangeMapper
.selectOneByExample(
    Example.builder(ReturnExchange.class)
    .where(WeekendSqls.<ReturnExchange>custom()
           .andEqualTo(ReturnExchange::getWaybillCode, waybillCode)
          )
    .build());
}
```

### 分页查询
```java
PageHelper.startPage(downloadTaskParam.getPageNum(), downloadTaskParam.getPageSize());
List<DownloadTaskDto> pageList = downloadTaskManager.page(downloadTaskParam);
PageBean<DownloadTaskVo> pageBean = BeanExUtil.copyPageBean(
    new PageBean<>(pageList), 
    downloadTaskDto -> BeanExUtil.copyProperties(downloadTaskDto, DownloadTaskVo.class)
);
```

## 插入示例
### 普通插入
```java
waybillDetailMapper.insertSelective(waybillDetail);
```

### 批量插入
```java
waybillDetailMapper.insertBatchListSelective(waybillDetailList);
```

## 更新示例
### 按条件更新
```java
FineRegister updateObject = new FineRegister();
updateObject.setStatus(WhetherEnum.YSE.getCode());
Example example = Example.builder(FineRegister.class)
.where(WeekendSqls.<FineRegister>custom()
       .andIn(FineRegister::getId, ids)
       .andEqualTo(FineRegister::getStatus, WhetherEnum.NO.getCode())
      ).build();
fineRegisterMapper.updateByExampleSelective(updateObject, example);
```

### 批量更新
```xml
<update id="batchUpdateWaybill">
  <foreach collection="list" item="item" index="index" open="" close="" separator=";">
    update tt_waybill
    <trim prefix="set" suffixOverrides=",">
      <if test="waybillStatusSet != null and waybillStatusSet.size() > 0">
          AND tw.waybill_status IN
          <foreach collection="waybillStatusSet" item="item" index="index" open="(" close=")" separator=",">
              #{item}
          </foreach>
      </if>
      <if test="item.releaseStatus!=null and item.releaseStatus!=''">release_status=#{item.releaseStatus},</if>
    </trim>
        where code = #{item.code}
    </foreach>
</update>
```

## 工具类
1. ServletUtil（请求参数获取、HTTP对象访问、HTTP头信息处理、响应内容渲染）
2. SecurityUtil（用户信息获取、 国家和时区信息获取、管理员校验、密码处理、获取令牌）
3. IRedissionLock（封装redison的分布式锁工具）
4. RedisCacheUtils（封装redis操作的工具）
5. 线程池 （ThreadPoolManager）
6. 时间类 DateUtil.getNowDate()



# 基础服务业务梳理
• - 数据模型及路径：  
      - 员工相关表：ts_staff（员工信息）、ts_user（用户账号）、ts_user_role（用户角色映射）、ts_role（角色定义）、ts_role_site_type（角色与站点类型关联）、ts_role_site_attribute（角色  
        与站点属性关联）、ts_role_menu（角色与菜单权限关联）  
      - 关键代码路径：员工管理核心在StaffServiceImpl，站点管理在SiteManagerImpl，角色管理相关逻辑在角色管理模块

+ **员工（Staff）与站点的关系：**
    - **员工属于特定站点（belongSite），站点存在层级结构（总部 SL01 -> 财务中心 SL02 -> 分拨中心 SL03 -> 一线 SL04 -> 二线 SL05）**
    - **站点带有类型（siteType）、父级编码(parentCode)、财务中心代码(financeCenter)、属性（直销/联营/三方）**
+ **角色与权限管理：**
    - **角色关联菜单权限，通过ts_role_menu管理，权限控制依赖角色菜单权限实现**
    - **角色关联站点类型和站点属性，用于限制角色的适用范围和分配逻辑，角色还能根据站点类型通过listRoleBySiteType查询筛选**
    - **特殊角色（如AllAuthRole）不参与常规更新**
    - **权限校验依赖于PreAuthorize注解及对应的切面，基于用户角色码及权限字符串进行访问控制。登录Token包含用户代码等信息**
+ **业务流程简述：**
    1. **站点创建：使用SiteManagerImpl.insert等接口创建站点并维护层级及属性关系，同时执行状态推送和子级级联更新**
    2. **角色管理：创建角色时关联菜单权限，并可配置限制适用的站点类型与属性，角色用于权限分配和过滤**
    3. **员工入职：**
        * **在StaffServiceImpl.save中验证站点存在，依据国家和地区码生成员工编码**
        * **创建员工实体及对应用户账号（用户名即员工编码），设置加密密码并发送随机密码邮件**
        * **分配员工类型及角色映射（在ts_user_role中），角色分配时受站点及角色限制控制**
    4. **登录认证：**
        * **通过TokenService签发包含用户信息的Token**
        * **请求时通过PreAuthorize确保访问接口的权限，用户绑定站点信息放在请求头DETAILS_USER_SITE**
    5. **员工更新与状态管理：**
        * **更新员工资料时重新分配员工类型及角色，清除旧Token实现强制登出**
        * **员工状态禁用时也清除Token，保证安全**
        * **站点状态变更时向子级传递同步，触发相关权限及访问控制更新**
+ **总结：**
    - **员工信息、用户账号和角色权限通过多表关联实现精细控制**
    - **角色权限配置与站点类型、属性紧密结合以支持多层级、多属性站点的权限细分**
    - **权限校验实现基于Token的安全认证与注解权限控制**
    - **相关实现代码主要集中于StaffServiceImpl（员工）、SiteManagerImpl（站点）、TokenService（认证），结合数据模型表配合实现业务流程及权限管理逻辑**
    - ****

**• 业务关系梳理**

+ **员工：ts_staff 表，字段见 speedaf-cheetah-basic-common/.../model/Staff.java。核心关联有员工编码 code（同时作为登录账号）、所属网点 belongSite、所属国家/财务中心信息及员工类型集合  
****（ts_staff_type，见 StaffType.java，类型枚举 StaffTypeEnum 如骑手/司机/客服等）。**
+ **账号与员工：新增员工时在 StaffManagerImpl.saveStaff（speedaf-cheetah-basic-service-provider/.../StaffManagerImpl.java）同步创建系统账号 ts_user（User.java），账号名即员工编码，密码  
****随机生成后加密，便于统一登录。**
+ **角色与权限：角色模型 ts_role（Role.java）通过 ts_role_menu 关联菜单/权限；RoleManagerImpl（同路径）在新增/修改角色时写入菜单权限，并额外维护角色可适用的网点类型 ts_role_site_type  
****和网点性质 ts_role_site_attribute，用于控制角色适用范围。**
+ **员工角色绑定：ts_user_role（UserRole.java）把账号与角色绑定；StaffManagerImpl.saveStaffRole 负责在员工创建/更新时落表。**
+ **网点层级：SiteManagerImpl（speedaf-cheetah-basic-service-provider/.../SiteManagerImpl.java）维护网点 ts_site，类型枚举 SiteTypeEnum：总部 SL01 → 财务中心 SL02 → 分拨中心 SL03 →  
****一  
****级网点 SL04 → 二级网点 SL05；网点性质枚举 SiteAttributeEnum（直营/加盟/第三方）。更新网点时会级联禁用下级并向外系统推送。**
+ **安全与鉴权：登录发放 token 见 TokenService（speedaf-cheetah-basic-common-security/.../TokenService.java），token 与账号绑定；权限检查通过自定义 @PreAuthorize 切面  
****（PreAuthorizeAspect）根据用户持有的角色/权限字符串判断是否可访问接口。SecurityUtil 负责从请求头解析当前用户、所属网点、网点类型等上下文。**

**  核心业务流程**

+ **角色配置：先依据业务定义角色，绑定菜单权限，并配置可用的网点类型/性质限制（RoleManagerImpl.saveRole）。全量权限角色（AllAuthRoleConfig 中配置）不更新网点限制。**
+ **网点维护：按层级创建/更新网点（SiteManagerImpl.insert/update），设置 siteType、parentCode、financeCenter、siteAttribute 等；禁用上级会级联禁用下级。**
+ **员工入职：前端提交员工信息与所属网点、类型和待分配角色 → StaffServiceImpl.save 校验网点和国家，生成唯一员工编码，写入 ts_staff，创建账号 ts_user，批量写入员工类型，绑定角色  
****（ts_user_role），并邮件发送初始密码。**
+ **员工权限生效：登录后通过 TokenService.createToken 生成 token，后续请求携带 token 与用户上下文头信息，PreAuthorizeAspect 根据账号拥有的角色/权限控制接口访问。**
+ **员工变更/离职：StaffServiceImpl.update/updateStatus 重新落库员工信息、类型、角色，若变更角色或禁用员工则删除 token 强制下线；更新员工所属网点或状态时依赖 SiteService 校验网点有  
****效性。**
+ **查询/派工：根据当前登录用户的国家与网点，员工查询接口会按网点层级、角色、员工类型做过滤（如调度、骑手、销售等在 StaffServiceImpl.dispatcherQuery / sellerQuery 等处体现）。**

<font style="color:rgb(31, 31, 31);"></font>

